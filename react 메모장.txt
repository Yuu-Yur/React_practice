3. 컴포넌트
useState()
hooks 중 useState는 배열을 반환함
이 배열은 두개의 값을 가지는 배열을 반환함
[data, setter]
이것을 할당할 때
인덱스 0 에는 변수명으로
인덱스 1 에는 이 변수의 setter 를 할당해줌
그리고 () 안에는 이 데이터의 초기값을 씀
즉
const [message, setMessage] = useState('');
로 쓰면 message 라는 변수의 초기값은 ''이고
setMessage 로 message 를 set할 수 있음

4. 이벤트 핸들러
const method = () => function
parameter 가 없으면 바로 method 를 써도 되지만
parameter 가 있는 경우 method 를 함수형태로 써야한다.
() => method()

state setter 이벤트 핸들러를 재사용 하기 위해
태그의 name 을 state 와 같게 지정하면 저장된다.
this.setState({
      username: '',
      message: ''
    });
이 상태에서 
name 이 username 인 태그와 message 인 태그에
동일한
handleChange = e => {
this.setState({
[e. target.name]: e.target.value
});
}
를 걸어주면 각각의 state 에 입력한 값이 들어간다.


크게 4가지 경우에 rerendering 하는데
그 중 하나인 state 의 변화는 조심해서 다뤄야 한다.
state 의 변화를 남발하면 state 변화 , rerendering , state 변화, rerendering...
연쇄작용으로 infinite loop 의 위험이 발생한다.


onKeyPress (e.target == enter) => onClick 이런식의 연쇄로
enter 키가 특정 버튼을 클릭 한 것과 같은 효과를 낼 수도 있다.

5. ref
react 에선 id 는 잘 사용하지 않고 ref 를 사용한다.
다만 id 를 사용해야 할 땐 id 뒤에 추가 텍스트를 붙여 중복을 방지함
ref 는 크게 두가지 방법으로 사용함.

1.지정하고 싶은 요소에 ref 라는 콜백함수를 props 로 전달
<input ref={(ref) => {this.input = ref}} />
이렇게 찍으면 this.input 은 위의 input 을 가르킨다.
즉 id를 지정하는 것과 비슷하게 ref 를 지정하는데 화살표 함수의 parameter 를 ref 로 사용하는것이다.

2. createRef 를 통해 설정
input = React.createRef();
<input ref={this.input} />
다만 사용할 때 this.input 이 아니라 this.input.current 를 사용해야 한다.


부모-자식간에 이벤트 리스너-핸들러 바인딩
부모가 자식컴포넌트를 쓸 때 이벤트 리스너를 props 로 쓰고 부모의 이벤트핸들러를 쓰고
자식이 이벤트 리스너를 쓸 때 이벤트 핸들러로 props.부모의 이벤트 리스너를 쓰면
자식의 이벤트가 일어났을 때 부모의 이벤트 핸들러를 작동할 수 있다.
추가로 부모의 이벤트 핸들러에서 자식의 이벤트 핸들러를 부르면
자식의 이벤트 -> 자식의 이벤트 리스너 -> 부모의 이벤트 리스너 -> 부모의 이벤트 핸들러 -> 자식의 이벤트 핸들러
이 과정에서 부모가 자식의 요소를 쓸 수 있다

// 주의점 스크롤 의 ScrollTop 은 화면 픽셀에 영향을 받는다.


6.컴포넌트 반복
map(함수) 기본 함수형태나 익명함수 형태나 많이 써왔던 그것
기존 객체는 그대로 두고 기존 객체를 가지고 새로운 객체를 만드는 것
concat(요소(객체)) 이것도 기존 객체를 변경하는 것이 아니라 요소를 추가한 새 객체를 만듬
filter 이것도 사용하던 것 조건에 맞는 객체만 남김, 조건을 !== 로 걸면 특정을 제외한 것만 남김 즉 특정한 것을 삭제