3. 컴포넌트
useState()
hooks 중 useState는 배열을 반환함
이 배열은 두개의 값을 가지는 배열을 반환함
[data, setter]
이것을 할당할 때
인덱스 0 에는 변수명으로
인덱스 1 에는 이 변수의 setter 를 할당해줌
그리고 () 안에는 이 데이터의 초기값을 씀
즉
const [message, setMessage] = useState('');
로 쓰면 message 라는 변수의 초기값은 ''이고
setMessage 로 message 를 set할 수 있음

4. 이벤트 핸들러
const method = () => function
parameter 가 없으면 바로 method 를 써도 되지만
parameter 가 있는 경우 method 를 함수형태로 써야한다.
() => method()

state setter 이벤트 핸들러를 재사용 하기 위해
태그의 name 을 state 와 같게 지정하면 저장된다.
this.setState({
      username: '',
      message: ''
    });
이 상태에서 
name 이 username 인 태그와 message 인 태그에
동일한
handleChange = e => {
this.setState({
[e. target.name]: e.target.value
});
}
를 걸어주면 각각의 state 에 입력한 값이 들어간다.


크게 4가지 경우에 rerendering 하는데
그 중 하나인 state 의 변화는 조심해서 다뤄야 한다.
state 의 변화를 남발하면 state 변화 , rerendering , state 변화, rerendering...
연쇄작용으로 infinite loop 의 위험이 발생한다.


onKeyPress (e.target == enter) => onClick 이런식의 연쇄로
enter 키가 특정 버튼을 클릭 한 것과 같은 효과를 낼 수도 있다.

5. ref
react 에선 id 는 잘 사용하지 않고 ref 를 사용한다.
다만 id 를 사용해야 할 땐 id 뒤에 추가 텍스트를 붙여 중복을 방지함
ref 는 크게 두가지 방법으로 사용함.

1.지정하고 싶은 요소에 ref 라는 콜백함수를 props 로 전달
<input ref={(ref) => {this.input = ref}} />
이렇게 찍으면 this.input 은 위의 input 을 가르킨다.
즉 id를 지정하는 것과 비슷하게 ref 를 지정하는데 화살표 함수의 parameter 를 ref 로 사용하는것이다.

2. createRef 를 통해 설정
input = React.createRef();
<input ref={this.input} />
다만 사용할 때 this.input 이 아니라 this.input.current 를 사용해야 한다.


부모-자식간에 이벤트 리스너-핸들러 바인딩
부모가 자식컴포넌트를 쓸 때 이벤트 리스너를 props 로 쓰고 부모의 이벤트핸들러를 쓰고
자식이 이벤트 리스너를 쓸 때 이벤트 핸들러로 props.부모의 이벤트 리스너를 쓰면
자식의 이벤트가 일어났을 때 부모의 이벤트 핸들러를 작동할 수 있다.
추가로 부모의 이벤트 핸들러에서 자식의 이벤트 핸들러를 부르면
자식의 이벤트 -> 자식의 이벤트 리스너 -> 부모의 이벤트 리스너 -> 부모의 이벤트 핸들러 -> 자식의 이벤트 핸들러
이 과정에서 부모가 자식의 요소를 쓸 수 있다

// 주의점 스크롤 의 ScrollTop 은 화면 픽셀에 영향을 받는다.


6.컴포넌트 반복
map(함수) 기본 함수형태나 익명함수 형태나 많이 써왔던 그것
기존 객체는 그대로 두고 기존 객체를 가지고 새로운 객체를 만드는 것
concat(요소(객체)) 이것도 기존 객체를 변경하는 것이 아니라 요소를 추가한 새 객체를 만듬
filter 이것도 사용하던 것 조건에 맞는 객체만 남김, 조건을 !== 로 걸면 특정을 제외한 것만 남김 즉 특정한 것을 삭제

const nextForm = { ...form, [e.target.name]: e.target.value, };
name.id === selected.id ? { ...name, text: updateInput } : name,
이런식으로 { 스프레드 연산자, 키:값의 형태 }를 쓴다면 객체의 특정 값을 덮어씌울 수 있음
스프레드 연산자는 완전히 같은걸 복사하여 반환, 다만 중첩된 객체나 배열은 참조로 복사
배열의 경우엔 뒤의 것을 추가함, 객체의 경우엔 뒤의 것으로 덮어씀


7. 컴포넌트 라이프사이클
라이프사이클메서드는 클래스형컴포넌트에서만 사용 가능
마운트, 업데이트, 언마운트
업데이트에도 4가지 경우 업데이트가 있음
-state, props 변경, 부모 컴포넌트의 리렌더링, 그리고 forceUpdate

7.1마운트
constructor(props) : 컴포넌트 생성자
getDerivedStateFromProps(nextProps,prevState) nextState 를 반환 : props 로 받은 값을 state 에 동기화
render() 화면 반환 : 화면 렌더링
componentDidMount() : js라이브러리나 프레임워크의 함수 호출, 이벤트 등록 등등 후처리

7.2업데이트
getDerivedStateFromProps(nextProps,prevState) nextState 반환
shouldComponentUpdate(nextProps,nextState) true,false 반환 : props 나 state 변경 시 리렌더링 여부 지정
render() 화면 반환
getSnapshotBeforeUpdate(prevProps,prevState) snapshot 반환 : render 결과가 브라우저에 반영되기 직전에 호출, 업데이트 직전 값을 참고할 일이 있을 때
componentDidUpdate(prevProps,prevState,snapshot) 반환값 없음 : render 완료 후 실행, prevProps, prevState, snapshot 을 받아 사용할 수 있음

7.3언마운트
componentWillUnmount() : componentDidMount 에서 등록한 것들을 제거해야함

7.4예외
componentDidCatch(error,info) : 에러 발생 시 사용
각각 무엇을 parameter 로 받는지 주의