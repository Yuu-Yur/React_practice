3. 컴포넌트
useState()
hooks 중 useState는 배열을 반환함
이 배열은 두개의 값을 가지는 배열을 반환함
[data, setter]
이것을 할당할 때
인덱스 0 에는 변수명으로
인덱스 1 에는 이 변수의 setter 를 할당해줌
그리고 () 안에는 이 데이터의 초기값을 씀
즉
const [message, setMessage] = useState('');
로 쓰면 message 라는 변수의 초기값은 ''이고
setMessage 로 message 를 set할 수 있음

4. 이벤트 핸들러
const method = () => function
parameter 가 없으면 바로 method 를 써도 되지만
parameter 가 있는 경우 method 를 함수형태로 써야한다.
() => method()

state setter 이벤트 핸들러를 재사용 하기 위해
태그의 name 을 state 와 같게 지정하면 저장된다.
this.setState({
      username: '',
      message: ''
    });
이 상태에서 
name 이 username 인 태그와 message 인 태그에
동일한
handleChange = e => {
this.setState({
[e. target.name]: e.target.value
});
}
를 걸어주면 각각의 state 에 입력한 값이 들어간다.


크게 4가지 경우에 rerendering 하는데
그 중 하나인 state 의 변화는 조심해서 다뤄야 한다.
state 의 변화를 남발하면 state 변화 , rerendering , state 변화, rerendering...
연쇄작용으로 infinite loop 의 위험이 발생한다.


onKeyPress (e.target == enter) => onClick 이런식의 연쇄로
enter 키가 특정 버튼을 클릭 한 것과 같은 효과를 낼 수도 있다.

5. ref
react 에선 id 는 잘 사용하지 않고 ref 를 사용한다.
다만 id 를 사용해야 할 땐 id 뒤에 추가 텍스트를 붙여 중복을 방지함
ref 는 크게 두가지 방법으로 사용함.

1.지정하고 싶은 요소에 ref 라는 콜백함수를 props 로 전달
<input ref={(ref) => {this.input = ref}} />
이렇게 찍으면 this.input 은 위의 input 을 가르킨다.
즉 id를 지정하는 것과 비슷하게 ref 를 지정하는데 화살표 함수의 parameter 를 ref 로 사용하는것이다.

2. createRef 를 통해 설정
input = React.createRef();
<input ref={this.input} />
다만 사용할 때 this.input 이 아니라 this.input.current 를 사용해야 한다.


부모-자식간에 이벤트 리스너-핸들러 바인딩
부모가 자식컴포넌트를 쓸 때 이벤트 리스너를 props 로 쓰고 부모의 이벤트핸들러를 쓰고
자식이 이벤트 리스너를 쓸 때 이벤트 핸들러로 props.부모의 이벤트 리스너를 쓰면
자식의 이벤트가 일어났을 때 부모의 이벤트 핸들러를 작동할 수 있다.
추가로 부모의 이벤트 핸들러에서 자식의 이벤트 핸들러를 부르면
자식의 이벤트 -> 자식의 이벤트 리스너 -> 부모의 이벤트 리스너 -> 부모의 이벤트 핸들러 -> 자식의 이벤트 핸들러
이 과정에서 부모가 자식의 요소를 쓸 수 있다

// 주의점 스크롤 의 ScrollTop 은 화면 픽셀에 영향을 받는다.


6.컴포넌트 반복
map(함수) 기본 함수형태나 익명함수 형태나 많이 써왔던 그것
기존 객체는 그대로 두고 기존 객체를 가지고 새로운 객체를 만드는 것
concat(요소(객체)) 이것도 기존 객체를 변경하는 것이 아니라 요소를 추가한 새 객체를 만듬
filter 이것도 사용하던 것 조건에 맞는 객체만 남김, 조건을 !== 로 걸면 특정을 제외한 것만 남김 즉 특정한 것을 삭제

const nextForm = { ...form, [e.target.name]: e.target.value, };
name.id === selected.id ? { ...name, text: updateInput } : name,
이런식으로 { 스프레드 연산자, 키:값의 형태 }를 쓴다면 객체의 특정 값을 덮어씌울 수 있음
스프레드 연산자는 완전히 같은걸 복사하여 반환, 다만 중첩된 객체나 배열은 참조로 복사
배열의 경우엔 뒤의 것을 추가함, 객체의 경우엔 뒤의 것으로 덮어씀


7. 컴포넌트 라이프사이클
라이프사이클메서드는 클래스형컴포넌트에서만 사용 가능
마운트, 업데이트, 언마운트
업데이트에도 4가지 경우 업데이트가 있음
-state, props 변경, 부모 컴포넌트의 리렌더링, 그리고 forceUpdate

7.1마운트
constructor(props) : 컴포넌트 생성자
getDerivedStateFromProps(nextProps,prevState) nextState 를 반환 : props 로 받은 값을 state 에 동기화
render() 화면 반환 : 화면 렌더링
componentDidMount() : js라이브러리나 프레임워크의 함수 호출, 이벤트 등록 등등 후처리

7.2업데이트
getDerivedStateFromProps(nextProps,prevState) nextState 반환
shouldComponentUpdate(nextProps,nextState) true,false 반환 : props 나 state 변경 시 리렌더링 여부 지정
render() 화면 반환
getSnapshotBeforeUpdate(prevProps,prevState) snapshot 반환 : render 결과가 브라우저에 반영되기 직전에 호출, 업데이트 직전 값을 참고할 일이 있을 때
componentDidUpdate(prevProps,prevState,snapshot) 반환값 없음 : render 완료 후 실행, prevProps, prevState, snapshot 을 받아 사용할 수 있음

7.3언마운트
componentWillUnmount() : componentDidMount 에서 등록한 것들을 제거해야함

7.4예외
componentDidCatch(error,info) : 에러 발생 시 사용
각각 무엇을 parameter 로 받는지 주의


8. Hooks
useState(초기값) : [변수, 세터] 를 반환함
useEffect(콜백함수, 의존성 배열) :  마운트 시 호출, 의존성 배열의 내용이 변경될 때마다 호출, 의존성 배열이 빈 배열이면 내용이 변경되지 않으므로 마운트 시 한번만 호출
                                  콜백함수 안에 쓰는 return 은 클린업함수, 클린업 함수는 콜백함수 보다 먼저 호출, 그리고 언마운트 시 클린업 함수만 호출됨
useReducer(리듀서 함수, 상태 초기값) :  action 값은 {type:'INCREMENT', ~:~, ~:~} 의 형태 , 현재state, 업데이트 정보 action 을 parameter 로 받아 새로운 state 를 반환
                                      결국 useState 와 같은데 setter(dispatch) 를 reducer(state,action) 으로 따로 정의 할 수 있음 state 는 useReducer 의 초기값으로 정의할 수 있고
                                      action 은 setter(dispatch) 의 parameter 로 넣어줄 수 있음
                                      즉 reducer 함수를 만들 때는 useReducer 에서 state 의 초기값을 정의하고, dispatch 의 parameter 로 넣어줄 값을 미리 정하고
                                      reducer 함수 안에서 사용하는것이 좋음
                                      아니면 아예 reducer 함수 안에서 써놓고 state 와 dispatch 의 parameter 에서 reducer 함수 안에서 정한 state.~ , action.~ 에서
                                      ~ 에 맞는 값을 넣어주어야함
                                      action 의 객체 중 키를 state 의 객체 키랑 같게 맞추면 {...state, [action.key] : action.value} 로 덮어쓸 수 있음
                                      한술 더 떠 e.target 을 써서 e.target.key 에 state 의 key 를 넣으면 e.target.key={key} 자동으로 state 와 action 이 연계됨
useMemo(반환값을 가지는 함수, 의존성 배열) : 의존성 배열의 값이 변경될 때만 함수 (실행하여) 결과 반환, 아니라면 전의 결과를 다시 사용
useCallback(콜백함수, 의존성 배열) :  의존성 배열의 값이 변경될 때만 콜백 함수 (생성하여) 반환, 단 주의점 : 콜백함수 안에 state 를 사용해야 할 때는 그 state 는 무조건 의존성 배열에 들어가야 함
                                    아니 state 를 쓰는 함수는 useCallback 을 사용할 필요가 없음
                                    ref 를 쓴다면 ref.current 를 쓰고 의존성 배열에서 지울 수 있긴 함
const 변수명 = useRef(null) : 변수명을 ref 로 사용할 수 있게 함 이후 참조하고 싶은 곳에 ref={변수명} null 을 쓰는 이유는 빈 참조객체를 반환하게 하기 위함
로컬 변수, 렌더링과 상관 없는 값을 정 써야한다면 사용, ref사용
const 변수명 = useRef(값); 이후 setter 로 변수명.current = 바꿀 값; 으로 쓸 수 있음 , react 의 기본 정신에 위배되므로 가급적 쓰지 말것
커스텀Hooks
use~~~.jsx 의 커스텀 hooks 를 만들고 이것을 export default function use~~~(return ~~){}  의 형태로 쓰면
이것을 import 해와서 반환을 쓸 수 있음, 즉 그냥 각종 기능을 여러번 작성해야 하는 경우 이것을 커스텀 hooks 로 만들어 빼두고 import 해오는것 뿐이다.